{"version":3,"file":"streaming.js","sources":["../../../../src/utils/anthropic-ai/streaming.ts"],"sourcesContent":["import { captureException } from '../../exports';\nimport { SPAN_STATUS_ERROR } from '../../tracing';\nimport type { Span } from '../../types-hoist/span';\nimport {\n  GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE,\n  GEN_AI_RESPONSE_ID_ATTRIBUTE,\n  GEN_AI_RESPONSE_MODEL_ATTRIBUTE,\n  GEN_AI_RESPONSE_STREAMING_ATTRIBUTE,\n  GEN_AI_RESPONSE_TEXT_ATTRIBUTE,\n  GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE,\n} from '../ai/gen-ai-attributes';\nimport { setTokenUsageAttributes } from '../ai/utils';\nimport type { AnthropicAiStreamingEvent } from './types';\n\n/**\n * State object used to accumulate information from a stream of Anthropic AI events.\n */\n\ninterface StreamingState {\n  /** Collected response text fragments (for output recording). */\n  responseTexts: string[];\n  /** Reasons for finishing the response, as reported by the API. */\n  finishReasons: string[];\n  /** The response ID. */\n  responseId: string;\n  /** The model name. */\n  responseModel: string;\n  /** Number of prompt/input tokens used. */\n  promptTokens: number | undefined;\n  /** Number of completion/output tokens used. */\n  completionTokens: number | undefined;\n  /** Number of cache creation input tokens used. */\n  cacheCreationInputTokens: number | undefined;\n  /** Number of cache read input tokens used. */\n  cacheReadInputTokens: number | undefined;\n  /** Accumulated tool calls (finalized) */\n  toolCalls: Array<Record<string, unknown>>;\n  /** In-progress tool call blocks keyed by index */\n  activeToolBlocks: Record<\n    number,\n    {\n      id?: string;\n      name?: string;\n      inputJsonParts: string[];\n    }\n  >;\n}\n\n/**\n * Checks if an event is an error event\n * @param event - The event to process\n * @param state - The state of the streaming process\n * @param recordOutputs - Whether to record outputs\n * @param span - The span to update\n * @returns Whether an error occurred\n */\n\nfunction isErrorEvent(event: AnthropicAiStreamingEvent, span: Span): boolean {\n  if ('type' in event && typeof event.type === 'string') {\n    // If the event is an error, set the span status and capture the error\n    // These error events are not rejected by the API by default, but are sent as metadata of the response\n    if (event.type === 'error') {\n      const message = event.error?.message ?? 'internal_error';\n      span.setStatus({ code: SPAN_STATUS_ERROR, message });\n      captureException(new Error(`anthropic_stream_error: ${message}`), {\n        mechanism: {\n          handled: false,\n          type: 'auto.ai.anthropic',\n          data: {\n            function: 'anthropic_stream_error',\n          },\n        },\n        data: {\n          function: 'anthropic_stream_error',\n        },\n      });\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Processes the message metadata of an event\n * @param event - The event to process\n * @param state - The state of the streaming process\n */\n\nfunction handleMessageMetadata(event: AnthropicAiStreamingEvent, state: StreamingState): void {\n  // The token counts shown in the usage field of the message_delta event are cumulative.\n  // @see https://docs.anthropic.com/en/docs/build-with-claude/streaming#event-types\n  if (event.type === 'message_delta' && event.usage) {\n    if ('output_tokens' in event.usage && typeof event.usage.output_tokens === 'number') {\n      state.completionTokens = event.usage.output_tokens;\n    }\n  }\n\n  if (event.message) {\n    const message = event.message;\n\n    if (message.id) state.responseId = message.id;\n    if (message.model) state.responseModel = message.model;\n    if (message.stop_reason) state.finishReasons.push(message.stop_reason);\n\n    if (message.usage) {\n      if (typeof message.usage.input_tokens === 'number') state.promptTokens = message.usage.input_tokens;\n      if (typeof message.usage.cache_creation_input_tokens === 'number')\n        state.cacheCreationInputTokens = message.usage.cache_creation_input_tokens;\n      if (typeof message.usage.cache_read_input_tokens === 'number')\n        state.cacheReadInputTokens = message.usage.cache_read_input_tokens;\n    }\n  }\n}\n\n/**\n * Handle start of a content block (e.g., tool_use)\n */\nfunction handleContentBlockStart(event: AnthropicAiStreamingEvent, state: StreamingState): void {\n  if (event.type !== 'content_block_start' || typeof event.index !== 'number' || !event.content_block) return;\n  if (event.content_block.type === 'tool_use' || event.content_block.type === 'server_tool_use') {\n    state.activeToolBlocks[event.index] = {\n      id: event.content_block.id,\n      name: event.content_block.name,\n      inputJsonParts: [],\n    };\n  }\n}\n\n/**\n * Handle deltas of a content block, including input_json_delta for tool_use\n */\nfunction handleContentBlockDelta(\n  event: AnthropicAiStreamingEvent,\n  state: StreamingState,\n  recordOutputs: boolean,\n): void {\n  if (event.type !== 'content_block_delta' || !event.delta) return;\n\n  // Accumulate tool_use input JSON deltas only when we have an index and an active tool block\n  if (\n    typeof event.index === 'number' &&\n    'partial_json' in event.delta &&\n    typeof event.delta.partial_json === 'string'\n  ) {\n    const active = state.activeToolBlocks[event.index];\n    if (active) {\n      active.inputJsonParts.push(event.delta.partial_json);\n    }\n  }\n\n  // Accumulate streamed response text regardless of index\n  if (recordOutputs && typeof event.delta.text === 'string') {\n    state.responseTexts.push(event.delta.text);\n  }\n}\n\n/**\n * Handle stop of a content block; finalize tool_use entries\n */\nfunction handleContentBlockStop(event: AnthropicAiStreamingEvent, state: StreamingState): void {\n  if (event.type !== 'content_block_stop' || typeof event.index !== 'number') return;\n\n  const active = state.activeToolBlocks[event.index];\n  if (!active) return;\n\n  const raw = active.inputJsonParts.join('');\n  let parsedInput: unknown;\n\n  try {\n    parsedInput = raw ? JSON.parse(raw) : {};\n  } catch {\n    parsedInput = { __unparsed: raw };\n  }\n\n  state.toolCalls.push({\n    type: 'tool_use',\n    id: active.id,\n    name: active.name,\n    input: parsedInput,\n  });\n\n  // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n  delete state.activeToolBlocks[event.index];\n}\n\n/**\n * Processes an event\n * @param event - The event to process\n * @param state - The state of the streaming process\n * @param recordOutputs - Whether to record outputs\n * @param span - The span to update\n */\n\nfunction processEvent(\n  event: AnthropicAiStreamingEvent,\n  state: StreamingState,\n  recordOutputs: boolean,\n  span: Span,\n): void {\n  if (!(event && typeof event === 'object')) {\n    return;\n  }\n\n  const isError = isErrorEvent(event, span);\n  if (isError) return;\n\n  handleMessageMetadata(event, state);\n\n  // Tool call events are sent via 3 separate events:\n  // - content_block_start (start of the tool call)\n  // - content_block_delta (delta aka input of the tool call)\n  // - content_block_stop (end of the tool call)\n  // We need to handle them all to capture the full tool call.\n  handleContentBlockStart(event, state);\n  handleContentBlockDelta(event, state, recordOutputs);\n  handleContentBlockStop(event, state);\n}\n\n/**\n * Instruments an async iterable stream of Anthropic events, updates the span with\n * streaming attributes and (optionally) the aggregated output text, and yields\n * each event from the input stream unchanged.\n */\nexport async function* instrumentStream(\n  stream: AsyncIterable<AnthropicAiStreamingEvent>,\n  span: Span,\n  recordOutputs: boolean,\n): AsyncGenerator<AnthropicAiStreamingEvent, void, unknown> {\n  const state: StreamingState = {\n    responseTexts: [],\n    finishReasons: [],\n    responseId: '',\n    responseModel: '',\n    promptTokens: undefined,\n    completionTokens: undefined,\n    cacheCreationInputTokens: undefined,\n    cacheReadInputTokens: undefined,\n    toolCalls: [],\n    activeToolBlocks: {},\n  };\n\n  try {\n    for await (const event of stream) {\n      processEvent(event, state, recordOutputs, span);\n      yield event;\n    }\n  } finally {\n    // Set common response attributes if available\n    if (state.responseId) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_ID_ATTRIBUTE]: state.responseId,\n      });\n    }\n    if (state.responseModel) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_MODEL_ATTRIBUTE]: state.responseModel,\n      });\n    }\n\n    setTokenUsageAttributes(\n      span,\n      state.promptTokens,\n      state.completionTokens,\n      state.cacheCreationInputTokens,\n      state.cacheReadInputTokens,\n    );\n\n    span.setAttributes({\n      [GEN_AI_RESPONSE_STREAMING_ATTRIBUTE]: true,\n    });\n\n    if (state.finishReasons.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE]: JSON.stringify(state.finishReasons),\n      });\n    }\n\n    if (recordOutputs && state.responseTexts.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TEXT_ATTRIBUTE]: state.responseTexts.join(''),\n      });\n    }\n\n    // Set tool calls if any were captured\n    if (recordOutputs && state.toolCalls.length > 0) {\n      span.setAttributes({\n        [GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE]: JSON.stringify(state.toolCalls),\n      });\n    }\n\n    span.end();\n  }\n}\n"],"names":["SPAN_STATUS_ERROR","captureException","GEN_AI_RESPONSE_ID_ATTRIBUTE","GEN_AI_RESPONSE_MODEL_ATTRIBUTE","setTokenUsageAttributes","GEN_AI_RESPONSE_STREAMING_ATTRIBUTE","GEN_AI_RESPONSE_FINISH_REASONS_ATTRIBUTE","GEN_AI_RESPONSE_TEXT_ATTRIBUTE","GEN_AI_RESPONSE_TOOL_CALLS_ATTRIBUTE"],"mappings":";;;;;;;AAcA;AACA;AACA;;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAS,YAAY,CAAC,KAAK,EAA6B,IAAI,EAAiB;AAC7E,EAAE,IAAI,MAAA,IAAU,KAAA,IAAS,OAAO,KAAK,CAAC,IAAA,KAAS,QAAQ,EAAE;AACzD;AACA;AACA,IAAI,IAAI,KAAK,CAAC,IAAA,KAAS,OAAO,EAAE;AAChC,MAAM,MAAM,UAAU,KAAK,CAAC,KAAK,EAAE,OAAA,IAAW,gBAAgB;AAC9D,MAAM,IAAI,CAAC,SAAS,CAAC,EAAE,IAAI,EAAEA,4BAAiB,EAAE,OAAA,EAAS,CAAC;AAC1D,MAAMC,0BAAgB,CAAC,IAAI,KAAK,CAAC,CAAC,wBAAwB,EAAE,OAAO,CAAC,CAAA,CAAA,EAAA;AACA,QAAA,SAAA,EAAA;AACA,UAAA,OAAA,EAAA,KAAA;AACA,UAAA,IAAA,EAAA,mBAAA;AACA,UAAA,IAAA,EAAA;AACA,YAAA,QAAA,EAAA,wBAAA;AACA,WAAA;AACA,SAAA;AACA,QAAA,IAAA,EAAA;AACA,UAAA,QAAA,EAAA,wBAAA;AACA,SAAA;AACA,OAAA,CAAA;AACA,MAAA,OAAA,IAAA;AACA;AACA;AACA,EAAA,OAAA,KAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,SAAA,qBAAA,CAAA,KAAA,EAAA,KAAA,EAAA;AACA;AACA;AACA,EAAA,IAAA,KAAA,CAAA,IAAA,KAAA,eAAA,IAAA,KAAA,CAAA,KAAA,EAAA;AACA,IAAA,IAAA,eAAA,IAAA,KAAA,CAAA,KAAA,IAAA,OAAA,KAAA,CAAA,KAAA,CAAA,aAAA,KAAA,QAAA,EAAA;AACA,MAAA,KAAA,CAAA,gBAAA,GAAA,KAAA,CAAA,KAAA,CAAA,aAAA;AACA;AACA;;AAEA,EAAA,IAAA,KAAA,CAAA,OAAA,EAAA;AACA,IAAA,MAAA,OAAA,GAAA,KAAA,CAAA,OAAA;;AAEA,IAAA,IAAA,OAAA,CAAA,EAAA,EAAA,KAAA,CAAA,UAAA,GAAA,OAAA,CAAA,EAAA;AACA,IAAA,IAAA,OAAA,CAAA,KAAA,EAAA,KAAA,CAAA,aAAA,GAAA,OAAA,CAAA,KAAA;AACA,IAAA,IAAA,OAAA,CAAA,WAAA,EAAA,KAAA,CAAA,aAAA,CAAA,IAAA,CAAA,OAAA,CAAA,WAAA,CAAA;;AAEA,IAAA,IAAA,OAAA,CAAA,KAAA,EAAA;AACA,MAAA,IAAA,OAAA,OAAA,CAAA,KAAA,CAAA,YAAA,KAAA,QAAA,EAAA,KAAA,CAAA,YAAA,GAAA,OAAA,CAAA,KAAA,CAAA,YAAA;AACA,MAAA,IAAA,OAAA,OAAA,CAAA,KAAA,CAAA,2BAAA,KAAA,QAAA;AACA,QAAA,KAAA,CAAA,wBAAA,GAAA,OAAA,CAAA,KAAA,CAAA,2BAAA;AACA,MAAA,IAAA,OAAA,OAAA,CAAA,KAAA,CAAA,uBAAA,KAAA,QAAA;AACA,QAAA,KAAA,CAAA,oBAAA,GAAA,OAAA,CAAA,KAAA,CAAA,uBAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAA,uBAAA,CAAA,KAAA,EAAA,KAAA,EAAA;AACA,EAAA,IAAA,KAAA,CAAA,IAAA,KAAA,qBAAA,IAAA,OAAA,KAAA,CAAA,KAAA,KAAA,QAAA,IAAA,CAAA,KAAA,CAAA,aAAA,EAAA;AACA,EAAA,IAAA,KAAA,CAAA,aAAA,CAAA,IAAA,KAAA,UAAA,IAAA,KAAA,CAAA,aAAA,CAAA,IAAA,KAAA,iBAAA,EAAA;AACA,IAAA,KAAA,CAAA,gBAAA,CAAA,KAAA,CAAA,KAAA,CAAA,GAAA;AACA,MAAA,EAAA,EAAA,KAAA,CAAA,aAAA,CAAA,EAAA;AACA,MAAA,IAAA,EAAA,KAAA,CAAA,aAAA,CAAA,IAAA;AACA,MAAA,cAAA,EAAA,EAAA;AACA,KAAA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAA,uBAAA;AACA,EAAA,KAAA;AACA,EAAA,KAAA;AACA,EAAA,aAAA;AACA,EAAA;AACA,EAAA,IAAA,KAAA,CAAA,IAAA,KAAA,qBAAA,IAAA,CAAA,KAAA,CAAA,KAAA,EAAA;;AAEA;AACA,EAAA;AACA,IAAA,OAAA,KAAA,CAAA,KAAA,KAAA,QAAA;AACA,IAAA,cAAA,IAAA,KAAA,CAAA,KAAA;AACA,IAAA,OAAA,KAAA,CAAA,KAAA,CAAA,YAAA,KAAA;AACA,IAAA;AACA,IAAA,MAAA,MAAA,GAAA,KAAA,CAAA,gBAAA,CAAA,KAAA,CAAA,KAAA,CAAA;AACA,IAAA,IAAA,MAAA,EAAA;AACA,MAAA,MAAA,CAAA,cAAA,CAAA,IAAA,CAAA,KAAA,CAAA,KAAA,CAAA,YAAA,CAAA;AACA;AACA;;AAEA;AACA,EAAA,IAAA,aAAA,IAAA,OAAA,KAAA,CAAA,KAAA,CAAA,IAAA,KAAA,QAAA,EAAA;AACA,IAAA,KAAA,CAAA,aAAA,CAAA,IAAA,CAAA,KAAA,CAAA,KAAA,CAAA,IAAA,CAAA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAA,sBAAA,CAAA,KAAA,EAAA,KAAA,EAAA;AACA,EAAA,IAAA,KAAA,CAAA,IAAA,KAAA,oBAAA,IAAA,OAAA,KAAA,CAAA,KAAA,KAAA,QAAA,EAAA;;AAEA,EAAA,MAAA,MAAA,GAAA,KAAA,CAAA,gBAAA,CAAA,KAAA,CAAA,KAAA,CAAA;AACA,EAAA,IAAA,CAAA,MAAA,EAAA;;AAEA,EAAA,MAAA,GAAA,GAAA,MAAA,CAAA,cAAA,CAAA,IAAA,CAAA,EAAA,CAAA;AACA,EAAA,IAAA,WAAA;;AAEA,EAAA,IAAA;AACA,IAAA,WAAA,GAAA,GAAA,GAAA,IAAA,CAAA,KAAA,CAAA,GAAA,CAAA,GAAA,EAAA;AACA,GAAA,CAAA,MAAA;AACA,IAAA,WAAA,GAAA,EAAA,UAAA,EAAA,GAAA,EAAA;AACA;;AAEA,EAAA,KAAA,CAAA,SAAA,CAAA,IAAA,CAAA;AACA,IAAA,IAAA,EAAA,UAAA;AACA,IAAA,EAAA,EAAA,MAAA,CAAA,EAAA;AACA,IAAA,IAAA,EAAA,MAAA,CAAA,IAAA;AACA,IAAA,KAAA,EAAA,WAAA;AACA,GAAA,CAAA;;AAEA;AACA,EAAA,OAAA,KAAA,CAAA,gBAAA,CAAA,KAAA,CAAA,KAAA,CAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAAA,YAAA;AACA,EAAA,KAAA;AACA,EAAA,KAAA;AACA,EAAA,aAAA;AACA,EAAA,IAAA;AACA,EAAA;AACA,EAAA,IAAA,EAAA,KAAA,IAAA,OAAA,KAAA,KAAA,QAAA,CAAA,EAAA;AACA,IAAA;AACA;;AAEA,EAAA,MAAA,OAAA,GAAA,YAAA,CAAA,KAAA,EAAA,IAAA,CAAA;AACA,EAAA,IAAA,OAAA,EAAA;;AAEA,EAAA,qBAAA,CAAA,KAAA,EAAA,KAAA,CAAA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAA,uBAAA,CAAA,KAAA,EAAA,KAAA,CAAA;AACA,EAAA,uBAAA,CAAA,KAAA,EAAA,KAAA,EAAA,aAAA,CAAA;AACA,EAAA,sBAAA,CAAA,KAAA,EAAA,KAAA,CAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gBAAA,gBAAA;AACA,EAAA,MAAA;AACA,EAAA,IAAA;AACA,EAAA,aAAA;AACA,EAAA;AACA,EAAA,MAAA,KAAA,GAAA;AACA,IAAA,aAAA,EAAA,EAAA;AACA,IAAA,aAAA,EAAA,EAAA;AACA,IAAA,UAAA,EAAA,EAAA;AACA,IAAA,aAAA,EAAA,EAAA;AACA,IAAA,YAAA,EAAA,SAAA;AACA,IAAA,gBAAA,EAAA,SAAA;AACA,IAAA,wBAAA,EAAA,SAAA;AACA,IAAA,oBAAA,EAAA,SAAA;AACA,IAAA,SAAA,EAAA,EAAA;AACA,IAAA,gBAAA,EAAA,EAAA;AACA,GAAA;;AAEA,EAAA,IAAA;AACA,IAAA,WAAA,MAAA,KAAA,IAAA,MAAA,EAAA;AACA,MAAA,YAAA,CAAA,KAAA,EAAA,KAAA,EAAA,aAAA,EAAA,IAAA,CAAA;AACA,MAAA,MAAA,KAAA;AACA;AACA,GAAA,SAAA;AACA;AACA,IAAA,IAAA,KAAA,CAAA,UAAA,EAAA;AACA,MAAA,IAAA,CAAA,aAAA,CAAA;AACA,QAAA,CAAAC,4CAAA,GAAA,KAAA,CAAA,UAAA;AACA,OAAA,CAAA;AACA;AACA,IAAA,IAAA,KAAA,CAAA,aAAA,EAAA;AACA,MAAA,IAAA,CAAA,aAAA,CAAA;AACA,QAAA,CAAAC,+CAAA,GAAA,KAAA,CAAA,aAAA;AACA,OAAA,CAAA;AACA;;AAEA,IAAAC,6BAAA;AACA,MAAA,IAAA;AACA,MAAA,KAAA,CAAA,YAAA;AACA,MAAA,KAAA,CAAA,gBAAA;AACA,MAAA,KAAA,CAAA,wBAAA;AACA,MAAA,KAAA,CAAA,oBAAA;AACA,KAAA;;AAEA,IAAA,IAAA,CAAA,aAAA,CAAA;AACA,MAAA,CAAAC,mDAAA,GAAA,IAAA;AACA,KAAA,CAAA;;AAEA,IAAA,IAAA,KAAA,CAAA,aAAA,CAAA,MAAA,GAAA,CAAA,EAAA;AACA,MAAA,IAAA,CAAA,aAAA,CAAA;AACA,QAAA,CAAAC,wDAAA,GAAA,IAAA,CAAA,SAAA,CAAA,KAAA,CAAA,aAAA,CAAA;AACA,OAAA,CAAA;AACA;;AAEA,IAAA,IAAA,aAAA,IAAA,KAAA,CAAA,aAAA,CAAA,MAAA,GAAA,CAAA,EAAA;AACA,MAAA,IAAA,CAAA,aAAA,CAAA;AACA,QAAA,CAAAC,8CAAA,GAAA,KAAA,CAAA,aAAA,CAAA,IAAA,CAAA,EAAA,CAAA;AACA,OAAA,CAAA;AACA;;AAEA;AACA,IAAA,IAAA,aAAA,IAAA,KAAA,CAAA,SAAA,CAAA,MAAA,GAAA,CAAA,EAAA;AACA,MAAA,IAAA,CAAA,aAAA,CAAA;AACA,QAAA,CAAAC,oDAAA,GAAA,IAAA,CAAA,SAAA,CAAA,KAAA,CAAA,SAAA,CAAA;AACA,OAAA,CAAA;AACA;;AAEA,IAAA,IAAA,CAAA,GAAA,EAAA;AACA;AACA;;;;"}