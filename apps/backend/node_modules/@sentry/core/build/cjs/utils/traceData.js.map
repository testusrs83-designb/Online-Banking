{"version":3,"file":"traceData.js","sources":["../../../src/utils/traceData.ts"],"sourcesContent":["import { getAsyncContextStrategy } from '../asyncContext';\nimport { getMainCarrier } from '../carrier';\nimport type { Client } from '../client';\nimport { getClient, getCurrentScope } from '../currentScopes';\nimport { isEnabled } from '../exports';\nimport type { Scope } from '../scope';\nimport { getDynamicSamplingContextFromScope, getDynamicSamplingContextFromSpan } from '../tracing';\nimport type { Span } from '../types-hoist/span';\nimport type { SerializedTraceData } from '../types-hoist/tracing';\nimport { dynamicSamplingContextToSentryBaggageHeader } from './baggage';\nimport { debug } from './debug-logger';\nimport { getActiveSpan, spanToTraceHeader } from './spanUtils';\nimport { extractTraceparentData, generateSentryTraceHeader, TRACEPARENT_REGEXP } from './tracing';\n\n/**\n * Extracts trace propagation data from the current span or from the client's scope (via transaction or propagation\n * context) and serializes it to `sentry-trace` and `baggage` values. These values can be used to propagate\n * a trace via our tracing Http headers or Html `<meta>` tags.\n *\n * This function also applies some validation to the generated sentry-trace and baggage values to ensure that\n * only valid strings are returned.\n *\n * If (@param options.propagateTraceparent) is `true`, the function will also generate a `traceparent` value,\n * following the W3C traceparent header format.\n *\n * @returns an object with the tracing data values. The object keys are the name of the tracing key to be used as header\n * or meta tag name.\n */\nexport function getTraceData(\n  options: { span?: Span; scope?: Scope; client?: Client; propagateTraceparent?: boolean } = {},\n): SerializedTraceData {\n  const client = options.client || getClient();\n  if (!isEnabled() || !client) {\n    return {};\n  }\n\n  const carrier = getMainCarrier();\n  const acs = getAsyncContextStrategy(carrier);\n  if (acs.getTraceData) {\n    return acs.getTraceData(options);\n  }\n\n  const scope = options.scope || getCurrentScope();\n  const span = options.span || getActiveSpan();\n  const sentryTrace = span ? spanToTraceHeader(span) : scopeToTraceHeader(scope);\n  const dsc = span ? getDynamicSamplingContextFromSpan(span) : getDynamicSamplingContextFromScope(client, scope);\n  const baggage = dynamicSamplingContextToSentryBaggageHeader(dsc);\n\n  const isValidSentryTraceHeader = TRACEPARENT_REGEXP.test(sentryTrace);\n  if (!isValidSentryTraceHeader) {\n    debug.warn('Invalid sentry-trace data. Cannot generate trace data');\n    return {};\n  }\n\n  const traceData: SerializedTraceData = {\n    'sentry-trace': sentryTrace,\n    baggage,\n  };\n\n  if (options.propagateTraceparent) {\n    const traceparent = _sentryTraceToTraceParentHeader(sentryTrace);\n    if (traceparent) {\n      traceData.traceparent = traceparent;\n    }\n  }\n\n  return traceData;\n}\n\n/**\n * Get a sentry-trace header value for the given scope.\n */\nfunction scopeToTraceHeader(scope: Scope): string {\n  const { traceId, sampled, propagationSpanId } = scope.getPropagationContext();\n  return generateSentryTraceHeader(traceId, propagationSpanId, sampled);\n}\n\n/**\n * Builds a W3C traceparent header from the given sentry-trace header.\n *\n * Why parse that header and not create traceparent from primitives?\n * We want these two headers to always have the same ids. The easiest way to do this is to take\n * one of them as the source of truth (sentry-trace) and derive the other from it.\n *\n * Most importantly, this guarantees parentSpanId consistency between sentry-trace and traceparent\n * in tracing without performance (TwP) mode, where we always generate a random parentSpanId.\n *\n * Exported for testing\n */\nexport function _sentryTraceToTraceParentHeader(sentryTrace: string): string | undefined {\n  const { traceId, parentSpanId, parentSampled } = extractTraceparentData(sentryTrace) || {};\n  if (!traceId || !parentSpanId) {\n    return undefined;\n  }\n  return `00-${traceId}-${parentSpanId}-${parentSampled ? '01' : '00'}`;\n}\n"],"names":["getClient","isEnabled","carrier","getMainCarrier","getAsyncContextStrategy","getCurrentScope","getActiveSpan","spanToTraceHeader","getDynamicSamplingContextFromSpan","getDynamicSamplingContextFromScope","baggage","dynamicSamplingContextToSentryBaggageHeader","TRACEPARENT_REGEXP","debug","generateSentryTraceHeader","extractTraceparentData"],"mappings":";;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,YAAY;AAC5B,EAAE,OAAO,GAAoF,EAAE;AAC/F,EAAuB;AACvB,EAAE,MAAM,SAAS,OAAO,CAAC,MAAA,IAAUA,uBAAS,EAAE;AAC9C,EAAE,IAAI,CAACC,mBAAS,EAAC,IAAK,CAAC,MAAM,EAAE;AAC/B,IAAI,OAAO,EAAE;AACb;;AAEA,EAAE,MAAMC,SAAA,GAAUC,sBAAc,EAAE;AAClC,EAAE,MAAM,GAAA,GAAMC,6BAAuB,CAACF,SAAO,CAAC;AAC9C,EAAE,IAAI,GAAG,CAAC,YAAY,EAAE;AACxB,IAAI,OAAO,GAAG,CAAC,YAAY,CAAC,OAAO,CAAC;AACpC;;AAEA,EAAE,MAAM,QAAQ,OAAO,CAAC,KAAA,IAASG,6BAAe,EAAE;AAClD,EAAE,MAAM,OAAO,OAAO,CAAC,IAAA,IAAQC,uBAAa,EAAE;AAC9C,EAAE,MAAM,WAAA,GAAc,IAAA,GAAOC,2BAAiB,CAAC,IAAI,CAAA,GAAI,kBAAkB,CAAC,KAAK,CAAC;AAChF,EAAE,MAAM,GAAA,GAAM,IAAA,GAAOC,wDAAiC,CAAC,IAAI,CAAA,GAAIC,yDAAkC,CAAC,MAAM,EAAE,KAAK,CAAC;AAChH,EAAE,MAAMC,SAAA,GAAUC,mDAA2C,CAAC,GAAG,CAAC;;AAElE,EAAE,MAAM,2BAA2BC,0BAAkB,CAAC,IAAI,CAAC,WAAW,CAAC;AACvE,EAAE,IAAI,CAAC,wBAAwB,EAAE;AACjC,IAAIC,iBAAK,CAAC,IAAI,CAAC,uDAAuD,CAAC;AACvE,IAAI,OAAO,EAAE;AACb;;AAEA,EAAE,MAAM,SAAS,GAAwB;AACzC,IAAI,cAAc,EAAE,WAAW;AAC/B,aAAIH,SAAO;AACX,GAAG;;AAEH,EAAE,IAAI,OAAO,CAAC,oBAAoB,EAAE;AACpC,IAAI,MAAM,WAAA,GAAc,+BAA+B,CAAC,WAAW,CAAC;AACpE,IAAI,IAAI,WAAW,EAAE;AACrB,MAAM,SAAS,CAAC,WAAA,GAAc,WAAW;AACzC;AACA;;AAEA,EAAE,OAAO,SAAS;AAClB;;AAEA;AACA;AACA;AACA,SAAS,kBAAkB,CAAC,KAAK,EAAiB;AAClD,EAAE,MAAM,EAAE,OAAO,EAAE,OAAO,EAAE,iBAAA,EAAkB,GAAI,KAAK,CAAC,qBAAqB,EAAE;AAC/E,EAAE,OAAOI,iCAAyB,CAAC,OAAO,EAAE,iBAAiB,EAAE,OAAO,CAAC;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS,+BAA+B,CAAC,WAAW,EAA8B;AACzF,EAAE,MAAM,EAAE,OAAO,EAAE,YAAY,EAAE,aAAA,EAAc,GAAIC,8BAAsB,CAAC,WAAW,CAAA,IAAK,EAAE;AAC5F,EAAE,IAAI,CAAC,WAAW,CAAC,YAAY,EAAE;AACjC,IAAI,OAAO,SAAS;AACpB;AACA,EAAE,OAAO,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC,EAAE,YAAY,CAAC,CAAC,EAAE,aAAA,GAAgB,OAAO,IAAI,CAAC,CAAA;AACA;;;;;"}